#include <stdio.h>
#include <xio.h>
#include "platform.h"
#include "xspi.h"
#include "xspi_l.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "cam_ctrl_header.h"
#include "vmodcam_header.h"
#include "pmodGYRO.h"
#include <stdint.h>

#include "game_board.h"
#include "game_controller.h"
#include "display.h"
#include "globals.h"
#include "xtmrctr.h"

#define blDvmaCR 0x00000000   // Control Reg Offset
#define blDvmaFWR 0x00000004  // Frame Width Reg Offset
#define blDvmaFHR 0x00000008  // Frame Height Reg Offset
#define blDvmaFBAR 0x0000000c // Frame Base Addr Reg Offset
#define blDvmaFLSR 0x00000010 // Frame Line Stride Reg Offeset
#define blDvmaHSR 0x00000014  // H Sync Reg Offset
#define blDvmaHBPR 0x00000018 // H Back Porch Reg Offset
#define blDvmaHFPR 0x0000001c // H Front Porch Reg Offset
#define blDvmaHTR 0x00000020  // H Total Reg Offset
#define blDvmaVSR 0x00000024  // V Sync Reg Offset
#define blDvmaVBPR 0x00000028 // V Back Porch Reg Offset
#define blDvmaVFPR 0x0000002c // V Front Porch Reg Offset
#define blDvmaVTR 0x00000030  // V Total Reg Offset

#define SCALE 10;

#define BUFFER_SIZE 5
static XSpi SPIINST;
Xuint8 readBuffer[BUFFER_SIZE] = {0, 0, 0, 0, 0};
Xuint8 writeBuffer[BUFFER_SIZE] = {0, 0, 0, 0, 0};

void print(char *str);

// Do whatever you want in here to play around with the Gyro
int16_t readGyro()
{
	PmodGYRO pgyr;

	GYRO_begin(&pgyr, XPAR_XPS_SPI_0_BASEADDR, XPAR_SPI_0_BASEADDR);
	//	GYRO_setThsXH(&pgyr, 0x0F);
	GYRO_enableInt1(&pgyr, INT1_XHIE);
	GYRO_enableInt2(&pgyr, REG3_I2_DRDY);

	u8 temp = 0x0F;
	GYRO_WriteReg(&pgyr, CTRL_REG1, &temp, 1);

	temp = 0x07;
	GYRO_WriteReg(&pgyr, CTRL_REG3, &temp, 1);
	temp = 1 << 4;
	GYRO_WriteReg(&pgyr, CTRL_REG4, &temp, 1);
	int16_t x, y, z;
	u8 temperature;
	u8 whoami = 0;
	GYRO_ReadReg(&pgyr, 0x0F, &whoami, 1);
	xil_printf("WHOAMI: %x \n\r", whoami);

	GYRO_begin(&pgyr, XPAR_XPS_SPI_0_BASEADDR, XPAR_SPI_0_BASEADDR);
	GYRO_ReadReg(&pgyr, OUT_X_H, &temp, 1);
	x = temp << 8;
	GYRO_ReadReg(&pgyr, OUT_X_L, &temp, 1);
	x |= temp;
	GYRO_end(&pgyr);

	//xil_printf("XX: %d, YY: %d, ZZ: %d, Temp: %d\n\r", xx >> 5 , yy >> 5, zz >> 5, temperature); // This just prints out all 0s ... so looks like that library's getX/Y/Z is incorrect
	return x; //(int16_t)(xx >> 5);


}

struct game g;
XTmrCtr timer;

int myabs(int x){
	return x < 0 ? -x : x;
}

int mymin(int x, int y){
	return x < y ? x : y;
}

int mymax(int x, int y){
	return x > y ? x : y;
}

int main()
{
	init_platform();
	/*
	 * Initialize system timer.
	 */
	XTmrCtr_Initialize(&timer, XPAR_TMRCTR_0_DEVICE_ID);

	//int calibrate =	gyroPlayground();

//	clearDisplay(BLACK);
	initGame(&g, 1);

	XTmrCtr_Start(&timer, 0);

	int a = 0;
	int xpos = 23;
//	while (!g.gameOver)
//	{
//		XTmrCtr_Reset(&timer, 0);
//		XTmrCtr_Start(&timer, 0);
//		int xposnew = readGyro();
//
////		xil_printf("Xposnew: %d\n\r", xpos);
//		xposnew /= 1024;
////		xil_printf("Xposnew: %d\n\r", xpos);
//
//		xpos += xposnew;
//		xpos = mymax(xpos, 0);
//		xpos = mymin(xpos, 47);
////		xil_printf("Xpos: %d\n\r", xpos);
////		xil_printf("%d\n", xpos); // doruk
//		propagateGame(&g);
//		movePlayer(&g, xpos, -1);
//		drawGameState(&g);
//		while (XTmrCtr_GetValue(&timer, 0) < SCREEN_REFRESH_PERIOD)
//		{
//		}
//		a++;
//	}
		CamIicCfg(XPAR_CAM_IIC_0_BASEADDR, CAM_CFG_640x480P);
		CamIicCfg(XPAR_CAM_IIC_1_BASEADDR, CAM_CFG_640x480P);
		CamCtrlInit(XPAR_CAM_CTRL_0_BASEADDR, CAM_CFG_640x480P, 640 * 2);
		CamCtrlInit(XPAR_CAM_CTRL_1_BASEADDR, CAM_CFG_640x480P, 0);

	drawGameState(&g);

	return 0;
}
